\documentclass{jsarticle}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[dvipdfmx]{color}
\usepackage{here}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{url}
\usepackage[hang,small,bf]{caption}
\usepackage[subrefformat=parens]{subcaption}
\usepackage{tikz}
\usepackage{siunitx}
\usepackage{bm}
\usepackage{ascmac}
\usepackage{booktabs}
\usepackage[top=15truemm,bottom=20truemm,left=20truemm,right=20truemm]{geometry}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary {shapes.misc}
\usetikzlibrary{positioning}
\captionsetup{compatibility=false}

\begin{document}

\section*{Sec3.3:Implementation of the simolex method}

この章ではシンプレクス法(単体法)を実行するいくつかの方法(2つ)について説明する。
アルゴリズムの概要から、ベクトル$\bm{B}^{-1}\bm{A}_j$が重要な役割を果たすことは明らか。
このベクトルが利用できる場合、被約費用、移動の方向、ステップサイズ$\theta^{*}$は簡単に計算できる。
したがって、2つの実装法の主な違いは、ベクトル$\bm{B}^{-1}\bm{A}_j$の計算方法と、ある反復から次の反復に運ばれる関連情報の量にある。\\
異なる実装法を比較するときは、
$(m\times m)$行列$\bm{B}$、ベクトル$\bm{b}\in \mathbb{R}^m$が与えられた時、
$\bm{B}$の逆行列の計算、$\bm{Bx} = \bm{b}$形式の線形システムを解くには$\mathcal{O}(m^3)$の計算量、
行列-ベクトル積$\bm{Bb}$の計算には、$\mathcal{O}(m^2)$の計算量、
2つの$m$次元ベクトルの内積$\bm{p}'\bm{b}$を計算するには、$\mathcal{O}(m^2)$の計算量が必要である、
ということに注意することが大切。(Sec1.6参照)\\

\section*{Naive implementation}
最初に、ある反復から次の反復に補助情報が伝達されない最も単純な実装法について説明する。
反復の開始時に、現在の基底変数の添字$B(1),...,B(m)$がある。
基底行列$\bm{B}$を作成し、未知のベクトル$\bm{p}$について線形システム$\bm{p}'\bm{B} = \bm{c}'_B$を解くことで、
$\bm{p}'=\bm{c}'_B\bm{B}^{-1}$が得られ、
ある変数$x_j$の被約費用$\bar{c_j}=c_j-\bm{c}'_B\bm{B}^{-1}\bm{A}_j$は
\begin{equation}
  \bar{c_j}=c_j-\bm{p}'\bm{A}_j
\end{equation}
で表せる。
採用するピボットルールに応じて、被約費用をすべて計算してもよいし、
負の被約費用を持つ変数に出会うまで1つずつ計算してもよい。
ベクトル$\bm{u}=\bm{B}^{-1}\bm{A}_j$を決定するため、基底となる列$\bm{A}_j$を選択し、線形連立方程式$\bm{Bu}=\bm{A}$を解く。
この時点で、現在の基本実行可能解からの移動方向を決めることができる。
最終的に$\theta^{*}$と、基底から外す変数を決定し、新しい基本実行可能解を構築する。

システム$\bm{p}'\bm{B} = \bm{c}'_B$や$\bm{Bu}=\bm{A}$を解くには$\mathcal{O}(m^3)$の計算量が必要であり、
さらに、すべての変数の被約費用を計算するには、非基底列$\bm{A}$のそれぞれとベクトル$\bm{p}$の内積を形成する必要があるため、
$\mathcal{O}(mn)$の計算量が必要です。
反復ごとの合計計算量は$\mathcal{O}(m^3+mn)$である。
(この後紹介する実装法では、$\mathcal{O}(m^2+mn)$の計算量で実装可能であることがわかる。)
したがって、ここで説明した実装法は、一般的にかなり非効率的である。
一方、特殊な構造に関する特定の問題の場合、線形システム$\bm{p}'\bm{B} = \bm{c}'_B$や$\bm{Bu}=\bm{A}$の計算は非常に高速である。
このような場合は、この実装法は実用上有効。
シンプレックス法をネットワークフローの問題に適用するときは、第7章でこの点を再検討する。

\section*{Revised dimplex method}
単純な実装法での計算負荷のほとんどは2つの線形連立方程式を解く必要からきている。
次の実装法では、行列$\bm{B}^{-1}$は各反復の開始時にすでに求められており、
ベクトル$\bm{c}'_B\bm{B}^{-1}$や$\bm{B}^{-1}\bm{A}_j$は、行列-ベクトル積によって計算できる。
このアプローチを実用的にするには、基底変換をするたびに行列$\bm{B}^{-1}$を更新する効率的な方法が必要である。
この方法を説明する。まず、
\begin{equation}
  \bm{B}=[\bm{A}_{B(1)} \cdots \bm{A}_{B(m)}]
\end{equation}
を反復開始時の基底行列とし、
\begin{equation}
  \bar{\bm{B}}=[\bm{A}_{B(1)} \cdots \bm{A}_{B(l-1)} \quad \bm{A}_j \quad \bm{A}_{B(l+1)} \cdots \bm{A}_{B(m)}]
\end{equation}
を次の反復の開始時の基底行列とする。
これらの2つの基底行列は、$l$番目の列$\bm{A}_{B(l)}$が${A}_j$に置き換えられている以外は、同じ列を持っている。
その場合、$\bm{B}^{-1}$には、$\bar{\bm{B}}^{-1}$の計算で利用できる情報が含まれていると予想できる。
これは実際に正しいことが証明できる。(演習3.13参照)

\begin{itembox}[l]{定義3.4}
  行列が与えられた場合、必ずしも正方形である必要はなく、ある行に同じ行もしくは別の行の定数倍を追加する操作は、
  elementary row operation(行基本変形)と呼ばれる。
\end{itembox}
次の例は、$\bm{Q}$を適切に構築された正方行列とした時、行列$\bm{C}$で行基本変形を実行することは、行列$\bm{QC}$を形成することと同等であることを示している。\\ 
Ex3.3\\
\begin{equation}
  \bm{Q} = 
  \begin{bmatrix}
    1 & 0 & 2 \\
    0 & 1 & 0 \\
    0 & 0 & 1
  \end{bmatrix}
  \quad,\quad
  \bm{C}=
  \begin{bmatrix}
    1 & 2 \\
    3 & 4 \\
    5 & 6 \\
  \end{bmatrix}
  \quad,\quad
  \bm{QC} = 
  \begin{bmatrix}
    11&14\\
    3&4\\
    5&6\\
  \end{bmatrix}
\end{equation}

行列$\bm{C}$左から行列$\bm{Q}$を掛けることは
$\bm{C}$の3番目の行に2を掛けて、最初の行に追加することと同値。
Ex3.3を一般化する。$\bm{D}_{ij}$を$i$行$j$列目の要素が$\beta$であり、それ以外が$0$の行列としたとき、
$j$番目の行に$\beta$を掛けて$i$番目の行に追加する($i\neq j$)ことは、
行列$\bm{Q} = \bm{I} + \bm{D}_{ij}$を左に掛けることと同じである。
このような行列$\bm{Q}$の行列式は$1$に等しいため、$\bm{Q}$は可逆である。 

ここで、$K$個の行基本変形のシーケンスを考え、その$k$番目の演算が特定の可逆行列$\bm{Q}_k$による左乗算に対応すると仮定する。
次に、この基本行演算のシーケンスは、可逆行列$\bm{Q}_K\bm{Q}_{K-1}\cdots\bm{Q}_2\bm{Q}_1$による左乗算と同じである。
与えられた行列に対して一連の行基本変形を実行することは、その行列に特定の可逆行列を左乗算することと同値であると結論付けることができる。 
  
$\bm{B}^{-1}\bm{B}=\bm{I}$より、$\bm{B}^{-1}\bm{A}_{B(i)}$は$i$番目の単位ベクトル$\bm{e}_i$であることが分かる。
このことから、$\bm{u}=\bm{B}^{-1}\bm{A}_j$とすると、
\begin{equation}
  \begin{array}{l}
  \bm{B}^{-1} \bar{\bm{B}}=\left[\begin{array}{ccccccc}
  \mid & & \mid & \mid & \mid & & \mid \\
  \mathbf{e}_{1} & \cdots & \mathrm{e}_{\ell-1} & \mathbf{u} & \mathbf{e}_{\ell+1} & \cdots & \mathbf{e}_{m} \\
  \mid & & \mid & \mid & \mid & & \mid
  \end{array}\right]
  =\left[\begin{array}{ccccc}
  1 & & u_{1} & & \\
  & \ddots & \vdots & & \\
  & & u_{\ell} & & \\
  & & \vdots & \ddots & \\
  & & u_{m} & & 1
  \end{array}\right]
  \end{array}
\end{equation}

上記の行列を単位行列に変更する行基本変形を考える。 次の行基本変形のシーケンスを検討する。
\begin{itemize}
  \item[(a)] それぞれ$i\neq j$について、$l$番目の行を$-\frac{u_i}{u_l}$倍したものを$i$番目の列に足す。これは、$u_i$を0で置き換えている。
  \item[(b)] $l$番目の行を$u_l$で割る。これは$u_l$を1で置き換えている。
\end{itemize}

この行基本変形のシーケンスは、$\bm{B}^{-1}\bar{\bm{B}}$に特定の可逆行列$\bm{Q}$を左乗算することと同じ。
結果は同一であるため、$\bm{Q}\bm{B}^{-1}\bar{\bm{B}}= \bm{I}$となり、$\bm{Q}\bm{B}^{-1}=\bar{\bm{B}}^{-1}$が得られる。
つまり、同じ一連の行基本変形を行列$\bm{B}^{-1}$に適用すると$\bar{\bm{B}}^{-1}$が得られることを示している。

Ex3.4\\
\begin{equation}
  \mathbf{B}^{-1}=\left[\begin{array}{rrr}
  1 & 2 & 3 \\
  -2 & 3 & 1 \\
  4 & -3 & -2
  \end{array}\right], \quad \mathbf{u}=\left[\begin{array}{r}
  -4 \\
  2 \\
  2
  \end{array}\right]
  \end{equation}
とし、$l=3$と仮定する。つまり、目的はベクトル$\bm{u}$を単位ベクトル$\bm{e}_3 =(0,0,1)$に変換することである。

3番目の行に2を掛けて、最初の行に追加、2番目の行から3番目の行を引く、最後に、3行目を2で割る。そうすると、
\begin{equation}
  \bar{\mathbf{B}}^{-1}=\left[\begin{array}{rrr}
  9 & -4 & -1 \\
  -6 & 6 & 3 \\
  2 & -1.5 & -1
  \end{array}\right]
  \end{equation}
が得られる。\\
説明した方法で$\bm{B}^{-1}$を更新することができるため、
行列$\bm{B}^{-1}$は各反復の開始時にすでに求められている状態でのシンプレクス法の実装が可能であることが分かる。
\begin{itembox}[l]{修正シンプレクス法の反復}
  \begin{itemize}
    \item[1] 通常の反復では、基底列$\bm{A}_{B(1)} \cdots \bm{A}_{B(m)}$、そこから得られる基本実行可能解$\bm{x}$、
    基底行列の逆行列である$\bm{B}^{-1}$から開始する。
    \item[2] 行ベクトル$\bm{p}'=\bm{c}'_B\bm{B}^{-1}$を計算し、被約費用$\bar{c}_j=c_j-\bm{p}'\bm{A}_j$を計算する。
    それらがすべて非負である場合、現在の基本実行可能解が最適であり、アルゴリズムは終了する。
    それ以外の場合は、$\bar{c}_j<0$を満たす$j$を選択する。
    \item[3] $\bm{u}=\bm{B}^{-1}\bm{A}_j$を計算する。$\bm{u}$の成分が正でない場合、最適コストは$-\infty$であり、アルゴリズムは終了する。
    \item[4]  $\bm{u}$の一部の成分が正の時、$\theta^{*}=\min_{\{i=1,\dots,m\mid u_i>0\}}{\frac{x_{B(i)}}{u_i}}$とする。
    \item[5]  $l$を$\theta^{*}=\frac{x_{B(l)}}{u_l}$とおく、$\bm{A}_{B(l)}$を$\bm{A}_{j}$で置き換えた基底を構成。
    $y_j=\theta^*,y_{B(i)}=x_{B(i)}-\theta^*u_i(i\neq l)$である$\bm{y}$を新しい基本実行可能解とする。
    \item[6] $(m\times (m+1))$行列である、$[\bm{B}^{-1}\mid \bm{u}]$を構成。
    最後の列を単位ベクトル$\bm{e}_l$に等しくなるように、各行に$l$番目の行の倍数を追加する。最初の$m$列が行列$\bar{\bm{B}}^{-1}$。
  \end{itemize}
\end{itembox}

\section*{The full tableau implementation}

次に、full tableauの観点からシンプレクス法の実装について説明する。
ここでは、行列$\bm{B}^{-1}$の維持や更新をする代わりに、
列$\bm{B}^{-1}\bm{b}$や$\bm{B}^{-1}\bm{A}_1,\dots,\bm{B}^{-1}\bm{A}_n$
を用いて、$m \times(n + 1)$行列$\bm{B}^{-1}[\bm{b}\mid \bm{A}]$を維持、更新する。
この行列をsimplex tableau と呼ぶ。

zeroth column と呼ばれる列$\bm{B}^{-1}\bm{b}=\bm{x}_B$であることに注意。
列$\bm{B}^{-1}\bm{A}_j$はタブローのi番目の列と呼ばれる。
新たに基底に加えられる変数に対応する列$\bm{u}=\bm{B}^{-1}\bm{A}_j$は、ピボット列、
$l$番目の基本変数が基底から外される場合、タブローの$l$番目の行はピボット行と呼ばれます。
最後に、ピボット行とピボット列の両方に属する要素は、ピボット要素と呼ばれる。
ピボット要素$u_l>0$に注意。
($\bm{u}<0$の時アルゴリズムはステップ3の終了条件を満たしている。)

タブローの行に含まれる情報は、下記の解釈を前提としている。
等式制約は、最初は$\bm{b}=\bm{Ax}$の形式で与えられる。
現在の基底行列$B$が与えられると、この等式制約はタブローの情報である、
$\bm{B^{-1}\bm{b}}=\bm{B}^{-1}\bm{Ax}$とも表せる。 
言い換えると、タブローの行は
等式制約$\bm{B^{-1}\bm{b}}=\bm{B}^{-1}\bm{Ax}$の係数を提供する。

各反復の終わりに、タブロー$\bm{B}^{-1}[\bm{b}\mid \bm{A}]$の更新、
$\bar{\bm{B}}^{-1}[\bm{b}\mid \bm{A}]$の計算をする必要がある。
これは、シンプレックスタブローに$\bm{Q}\bm{B}^{-l} = \bar{\bm{B}}^{-1}$
を満たす行列$\bm{Q}$を左乗算することで実現できる。
説明したように、これは$\bm{B}^{-l}$を$\bar{\bm{B}}^{-1}$に
変換する基本行演算を実行するのと同じ。
つまり、各行にピボット行の倍数を追加し、1であるピボット要素以外全ての
ピボット列を0にする。

シンプレックス法の要約のステップ4と5、つまり、
終了列$\bm{A}_{B(l)}$とステップサイズ$\theta ^*$の決定に関して、
$\frac{x_{B(i)}}{u_i}$は、0番目の列の$i$番目のエントリと
タブローのピボット列のi番目のエントリの比率。
$u_i$が正である$i$のみを考慮し、
最小の比率は$\theta ^*$に等しく、$l$が決定できる。

0番目の行と呼ばれる一番上の行を含めることによって
シンプレックスタブローを拡張するのが通例。
左上隅のエントリには、現在のコストの負の値である
$-\bm{c}'_B\bm{x}_B$が含まれている。
（マイナス記号の理由は、単純な更新ルールが可能であるため。）
0番目の行の残りの部分は、被約費用の行ベクトルです。
つまり、ベクトル$\bar{\bm{c}}'=\bm{c}'-\bm{C}'_B\bm{B}^{-1}\bm{A}$。
したがって、タブローの構造は、
\begin{equation}
  \begin{array}{|c|c|}
  \hline-\mathbf{c}_{B}^{\prime} \mathrm{B}^{-1} \mathbf{b} & \mathbf{c}^{\prime}-\mathbf{c}_{B}^{\prime} \mathbf{B}^{-1} \mathrm{~A} \\
  \hline \mathbf{B}^{-1} \mathbf{b} & \mathbf{B}^{-1} \mathbf{A} \\
  \hline
  \end{array}
\end{equation}
\begin{equation}
  \begin{array}{|c|ccc|}
  \hline-\mathbf{c}_{B}^{\prime} \mathbf{x}_{B} & \bar{c}_{1} & \cdots & \bar{c}_{n} \\
  \hline x_{B(1)} & \mid & & \mid \\
  \vdots & \mathbf{B}^{-1} \mathbf{A}_{1} & \cdots & \mathbf{B}^{-1} \mathbf{A}_{n} \\
  x_{B(m)} & \mid & & \mid \\
  \hline
  \end{array}
\end{equation}
となる。

0番目の行を更新するためのルールは、
タブローの他の行に使用されるルールと同じ。
ピボット行の倍数を0番目の行に追加して、
入力変数の被約費用をゼロに設定する。
ここで、この更新ルールが0番目の行に対しても正しい結果を
生成することを確認する。
典型的な反復の開始時に、0番目の行は
$[0\mid \bm{c}']-\bm{g}'[\bm{b}\mid \bm{A}](\bm{g}'[\bm{b}\mid \bm{A}])$
という形式になる。
したがって、0番目の行は$[0\mid \bm{c}']$と$[\bm{b}\mid \bm{A}]$
の行の線形結合。
列$j$をピボット列、行$l$をピボット行とする。
ピボット行の形式は$\bm{h}'[\bm{b}\mid \bm{A}]$。
ここで、ベクトル$\bm{h}'$は$\bm{B}^{-1}$の$l$番目の行。
したがって、ピボット行の倍数が0番目の行に追加された後、
その行は再び$[0\mid \bm{c}']$と$[\bm{b}\mid \bm{A}]$の
（異なる）線形結合であり、あるベクトル$\bm{p}$を用いて、
$[0\mid \bm{c}']-\bm{p}'[\bm{b}\mid \bm{A}]$で表される。
更新ルールでは、0番目の行のピボット列エントリがゼロになる。
つまり、
\begin{equation}
  c_{\bar{B}(\ell)}-\mathbf{p}^{\prime} \mathbf{A}_{\bar{B}(\ell)}=c_{j}-\mathbf{p}^{\prime} \mathbf{A}_{j}=0
\end{equation}
$i\neq l$の$\bar{\bm{B}}_{(i)}$番目の列について考える。
(これは、基底にとどまる基本変数に対応する列)
基底変数の被約費用のため、基底が変更される前は、
その列の0番目の行エントリはゼロ。
$\bar{\bm{B}}^{-1}\bm{A_{B(i)}}(i\neq l)$はi番目の単位ベクトルであるため、
その列のピボット行のエントリもゼロに等しくなる。
したがって、タブローの0番目の行にピボット行の倍数を追加しても、
その列の0番目の行エントリには影響せず、0のまま。
新しい基底のすべての列$\bm{A}_{\bar{B}(i)}$について、
ベクトル$\bm{p}$が
$c_{\bar{B}(i)}-\bm{p}'\bm{A}_{\bar{B}(i)}=0$
を満たすと結論付ける。
これは、$\bm{c}'_{\bar{B}}-\bm{p}'\bar{\bm{B}}=0$や
$\bm{p}'=\bm{c}'_{\bar{B}}\bar{\bm{B}}^{-1}$を意味する。
つまり、更新ルールでは、タブローの更新された0番目の行は、
$[0\mid \bm{c}']-\bm{c}'_{\bar{B}}\bar{\bm{B}}^{-1}[\bm{b}\mid \bm{A}]$
に等しくなります。

\begin{itembox}[l]{フルタブロー実装の反復}
  \begin{itemize}
    \item[1] 通常の反復は、基底行列$\bm{B}$と対応する基本実行可能解$\bm{x}$に関連付けられたタブローから開始する。
    \item[2] タブローの0行目での被約費用を調べる。それらが全て非負の場合、現在の基本実行可能解が最適であり、アルゴリズムは終了する。それ以外の場合は、$\bar{c}_j<0$を満たす$j$を選択する。
    \item[3] タブローの$j$番目の列（ピボット列）であるベクトル$\bm{u} =\bm{B}^{-1}\bm{A}_j$
    を考える。$\bm{u}$の成分が正でない場合、最適コストは$-\infty$であり、アルゴリズムは終了する。
    \item[4] $u_i$が正である各$i$について、比率$\frac{x_{B(i)}}{u_i}$を計算する。
    最小の比率に対応する行のインデックスを$l$とします。
    列$A_{B(l)}$は基底から外れ、列$\bm{A}_j$が基底に加わる
    \item[5] タブローの各行に、$l$番目の行(ピボット行)の定数倍を追加して、
    $u_l$(ピボット要素)を1、ピボット列の他のすべてのエントリを0にする。    
  \end{itemize}
\end{itembox}

Ex3.5\\
\begin{equation}
  \begin{array}{rr}
  \operatorname{minimize} & -10 x_{1}-12 x_{2}-12 x_{3} \\
  \text { subject to } & x_{1}+2 x_{2}+2 x_{3} \leq 20 \\
  &2 x_{1}+x_{2}+2 x_{3} \leq 20 \\
  &2 x_{1}+2 x_{2}+x_{3} \leq 20 \\
  & x_{1}, x_{2}, x_{3} \geq 0
  \end{array}
\end{equation}
Fig3.4に実行可能範囲が示されている。これを標準形になおすと、
\begin{equation}
  \begin{array}{rrrrrrrrrrrrrr}
    \operatorname{minimize} & -10 x_{1}&-&12 x_{2}&-&12 x_{3}&&&&&&& \\
    \text { subject to } & x_{1}&+&2 x_{2}&+&2 x_{3}&+&x_{4} &&&&& =20 \\
    &2 x_{1}&+&x_{2}&+&2 x_{3}&&&+&x_{5} &&& =20 \\
    &2 x_{1}&+&2 x_{2}&+&x_{3} &&&&& +&x_{6}&=20 \\
    &&x_{1},& \ldots,& x_{6}& \geq 0 &
  \end{array}
\end{equation}
この問題の基本実行可能解は$\bm{x}=(0,0,0,20,20,20)$であり、ここからアルゴリズムを始める。
$B(1)=4,B(2)=5,B(3)=6$であり、基底行列は単位行列$\bm{I}$である。
$\bm{c}_B=0,\bm{c}'_B\bm{x}_B=0,\bar{\bm{c}}=\bm{c}$であるため、最初のタブローは、

\begin{equation}
  \begin{array}{c|c|cccccc|}
    \cline{2-8} 
    && x_{1} & x_{2} & x_{3} & x_{4} & x_{5} & x_{6} \\
    \cline{2-8}   
    &0 & -10 & -12 & -12 & 0 & 0 & 0 \\
    \cline{2-8} 
    x_4=&20 & 1 & 2 & 2 & 1 & 0 & 0 \\
    x_5=&20 & 2^{*} & 1 & 2 & 0 & 1 & 0 \\
    x_6=&20 & 2 & 2 & 1 & 0 & 0 & 1 \\
    \cline{2-8} 
  \end{array}
\end{equation}
上記のタブローの形式での注意事項。
$i$番目の列の上部にあるラベル$x_i$は、その列に関連する変数を示す。
タブローの左側にあるラベル$x_i=$は、基本変数とその順序を示す。
例えば、最初の基本変数$x_{B(1)}=x_4$であり、その値は20。
最初の基本変数に関連するタブローの列は、最初の単位ベクトルでなければならない。
変数$x_4$に関連する列が最初の単位ベクトルであることがわかるため、
$x_4$が最初の基本変数となる。
$x_1$の被約費用は負であり、その変数を基底に加える。
ピボット列は$\bm{u}=(1,2,2)$。
比率$\frac{x_{B(i)}}{u_i}(i=1,2,3)$のうち、
最小の比率は、$i=2,3$の時。$l = 2$とする。
これにより、アスタリスクで示すピボット要素が決まる。
2番目の基本変数$x_{B(2)}=x_5$を基底から外す。
新しく加わる基底は$B(1)$
新たな基底として$\bar{B}(1)=4,\bar{B}(2)=1,\bar{3}(1)=6$が得られる。

ピボット行に5を掛けて、0番目の行に足す。
ピボット行に$frac{1}{2}$を掛けて、最初の行から引く。 
ピボット行を3番目から引く。
最後に、ピボット行を2で割る。
これにより、得られたタブローが下である。
\begin{equation}
  \begin{array}{c|c|cccccc|}
    \cline{2-8} 
    && x_{1} & x_{2} & x_{3} & x_{4} & x_{5} & x_{6} \\
    \cline{2-8}   
    &100 & 0 & -7 & -2 & 0 & 5 & 0 \\
    \cline{2-8} 
    x_4=&10&0 & 1.5 & 1^* & 1 & -0.5 & 0 \\
    x_1=&10&1 & 0.5 & 1 & 0 & 0.5 & 0 \\
    x_6=&0 & 0 & 1 & -1 & 0 & -1 & 1 \\
    \cline{2-8} 
  \end{array}
\end{equation}
この基本実行可能解は$\bm{x}=(10,0,0,10,0,0)$。Fig3.4で見ると、点Aから点Dに移動している。
$x_6=0$のため、縮退していることに注意。

タブローの行(0番目の行を除)は、元の制約$\bm{Ax}=\bm{b}$
と同等の等式制約$\bm{B}^{-1}\bm{Ax}=\bm{B}^{-l}\bm{b}$の表現になる。
現在のタブローでは、等式制約を
\begin{equation}
  \begin{array}{ccccccccccccc}
  10&=&&&1.5x_2&+&x_3&+&x_4&-&0.5x_5&&\\
  10&=&x_1&+&0.5x_2&+&x_3&&&+&0.5x_5&&\\
  1&=&&&x_2&-&x_3&&&-&x_5&+&x_6
  \end{array}
\end{equation}
のように表せる。

シンプレックス法に戻ります。 現在のタブローでは、
変数$x_2$と$x_3$の被約費用がマイナスになっている。
次に基底に加えるものとして$x_3$を選択。ピボット列は$\bm{u}=(1,1,-1)$。
$u_3<0$なので、比率$\frac{x_{B(i)}}{u_i}(i=1,2)$のみを考える。
$l = 1$とし、最初の基本変数$x_4$が基底から外す。
ピボット要素もアスタリスクで示されている。
先ほどと同様の基本行変形を実行した後、次の新しいタブローを得る。
\begin{equation}
  \begin{array}{c|c|cccccc|}
    \cline{2-8} 
    && x_{1} & x_{2} & x_{3} & x_{4} & x_{5} & x_{6} \\
    \cline{2-8}   
    &120 & 0 & -4 & 0 & 2 & 4 & 0 \\
    \cline{2-8} 
    x_3=&10&0 & 1.5 & 1 & 1 & -0.5 & 0 \\
    x_1=&0&1 & -1 & 0 & -1 & 1 & 0 \\
    x_6=&10 & 2.5^* & 0 & 1 & 0 & -1.5 & 1 \\
    \cline{2-8} 
  \end{array}
\end{equation}

Fig3.4で見ると、点Dから点Bに移動している。また、コストは-120。
ここで$x_2$のみが負の被約費用を持つ変数のため、$x_2$を基底に加え、$x_6$を基底から外す。
どうようの操作を行うと新たなタブローは、
\begin{equation}
  \begin{array}{c|c|cccccc|}
    \cline{2-8} 
    && x_{1} & x_{2} & x_{3} & x_{4} & x_{5} & x_{6} \\
    \cline{2-8}   
    &136 & 0 & 0 & 0 & 3.6 & 1.6 & 1.6 \\
    \cline{2-8} 
    x_3=&4&0 & 0 & 1 & 0.4 & 0.4 & -0.6 \\
    x_1=&4&1 & 0 & 0 &-0.6 & 0.4 & 0.4 \\
    x_2=&4&0 & 1 & 0 & 0.4 &-0.6 & 0.4 \\
    \cline{2-8} 
  \end{array}
\end{equation}
Fig3.4で見ると、点Bから点Eに移動している。
これが最適解であることは、
すべての被約費用が負ではないことから確認できる。
この例では、シンプレックス法は最適解に到達するために3つの基底変換を行い、
Fig3.4のA,D,B,Eと調べていった。
ピボットルールが異なるとすると、異なるルートで調べることとなる。
シンプレックス法は、2つのエッジ、2回の反復のみが含まれるルートA,D,Eと調べることで最適解を出せたのだろうか。
答えはいいえ。
最初と最後の基底は3つの列で異なるため、少なくとも3回の基底の変更が必要。
特に、A,D,Eと調べる場合、
ポイントDで基底変換が縮退する。これにより、合計が3回の変換が必要になる。

Ex3.6\\
シンプレックス法が実際に循環してしまう例。
次のピボットルールを使用。
\begin{itemize}
  \item[(a)] 最も負である被約費用$\bar{c}_j$を持つ非基本変数を
  次に基底に加える変数として選択する。
  \item[(b)] 基底から外すことのできる基本変数のうち、
  添字が最小の変数を選択する。 
\end{itemize}
そうすると、p104,105のようにタブローが変化する。

最後のタブローを見ると、最初と同じ基底を持つタブローとなっている。
基底変換のたびに、$\theta^* = 0$であり、同じコストを持っていた。
この例では、同様の操作を何度も繰り返すことになり、シンプレクス法を終了できない。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Comparison of the full tableau and the revised simplex methods}

問題が次のように変更されたとする。

\begin{equation}
  \begin{array}{rr}
  \operatorname{minimize} & \bm{c}'\bm{x}+\bm{0}'\bm{y} \\
  \text { subject to } & \bm{A}\bm{x}+\bm{I}\bm{y}=\bm{b} \\
  & \bm{x}, \bm{y} \geq 0
  \end{array}
\end{equation}

この問題にシンプレックス法を実装する。
ただし、ベクトル$\bm{y}$の要素を決して基底にしないこととし、
また、ベクトル$\bm{y}$が存在しないものとして基底の変更を行う。
この問題における被約費用のベクトルは

\begin{equation}
  \left[\mathbf{c}^{\prime} \mid 0^{\prime}\right]-\mathbf{c}_{B}^{\prime} \mathbf{B}^{-1}[\mathrm{~A} \mid \mathrm{I}]=\left[\overline{\mathbf{c}}^{\prime} \mid-\mathbf{c}_{B}^{\prime} \mathbf{B}^{-1}\right]
\end{equation}

したがって、この問題のシンプレックスタブローは以下の形式を取る。

\begin{equation}
  \begin{array}{|c|cc|}
  \hline-\mathbf{c}_{B}^{\prime} \mathbf{B}^{-1} \mathbf{b} & \overline{\mathbf{c}}^{\prime} & -\mathbf{c}_{B}^{\prime} \mathbf{B}^{-1} \\
  \hline \mathbf{B}^{-1} \mathbf{b} & \mathbf{B}^{-1} \mathbf{A} & \mathbf{B}^{-1} \\
  \hline
  \end{array}
\end{equation}

特に、
上記のタブローでフルタブロー法のアルゴリズム通りに行うことで、
逆基底行列$\bm{B}^{-1}$が各反復で利用できる。
これにより、改訂されたシンプレックス法は、
タブローのB-1Aなどの部分が明示的に形成されない代わりに、
入力変数xが選択されると、ピボット列$\bm{B}^{-1}\bm{A}$
をその場で計算すること以外は、
上記の拡張問題に適用されたフルタブロー法と本質的に同じである
と考えることができる。 
したがって、改訂されたシンプレックス法は、
より効率的な簿記を備えたフルタブロー法に変形したものであることが分かる。
改訂されたシンプレックス法が$\bm{B}^{-1}$の上にある0番目の行エントリも
（通常の基本操作によって）更新する場合、
シンプレックス乗数$\bm{p}'=\bm{c}'_B\bm{B}^{-1}$が
利用可能になるため、
各反復で線形システム$\bm{p}'\bm{B}=\bm{c}'_B$を解く必要がなくなる。

ここで、この2つの方法の相対的なメリットについて説明する。
フルタブロー法では、タブローの各エントリを更新するために、
ある一定かつ少数の算術演算が必要となる。
したがって、反復ごとの計算量は、タブローのサイズに比例するため、$\mathcal{O}(mn)$。
改訂されたシンプレックス法は、
同様の計算を使用して$\bm{B}^{-1}$と$\bm{c}'_B\bm{B}^{-1}$の更新、
つまり$\mathcal{O}(m^2)$エントリのみが更新されるため、
反復ごとの計算量は$\mathcal{O}(m^2)$。
さらに、各変数の被約費用は内積$\bm{p}'\bm{A}_j$を計算することに
よって求められるため、計算量は$\mathcal{O}(m)$
最悪の場合、すべての変数について被約費用が計算されるため、
反復ごとに合計$\mathcal{O}(mn)$の計算量が必要。
$m<n$であるため、どちらの実装でも、反復ごとの最悪の計算量は
$\mathcal{O}(mn+m^2)=\mathcal{O}(mn)$。 
一方、負の被約費用が見つかるまで一つずつの被約費用を計算するピボットルールを
検討する場合、改訂されたシンプレックス法の一般的な反復では、
はるかに少ない計算量で済む。
最良の場合、計算された最初の被約費用が負であり、
対応する変数が次に基底に加える変数として選択された場合、
合計の計算量は$\mathcal{O}(m^2)$。
結論として、改訂されたシンプレックス法はフルタブロー法より
計算量が大きくなることはなく、ほとんどの反復ではるかに小さい計算量で
計算可能である可能性がある。

改訂されたシンプレクス法のもう一つのメリットは、格納に必要なメモリが
$\mathcal{O}(mn)$から$\mathcal{O}(m^2)$に削減されていることである。
$n$は$m$よりはるかに大きいことが多いので、この効果はかなり大きい。
行列$\bm{A}$を保存する必要があるため、
修正シンプレックス法のメモリ要件も$\mathcal{O}(mn)$であると考えることもできる。
しかし、実際のアプリケーションで発生するほとんどの大規模問題では、
行列$\bm{A}$は非常にスパース(0エントリが多い状態)であり、
コンパクトに格納することができる。(なお、$\bm{A}$と$\bm{B}$がスパースであっても、
$\bm{B}^{-1}\bm{A}$は一般にスパースではないので、
$\bm{A}$のスパース性はフルシンプレックスタブローの格納要領の減少には通常役立たない)。

これまでの議論を以下の表にまとめる。
\begin{equation}
  \begin{array}{|l|c|c|}
  \hline & \text { Full tableau } & \text { Revised simplex } \\
  \hline \text { Memory } & O(m n) & O\left(m^{2}\right) \\
  \hline \text { Worst-case time } & O(m n) & O(m n) \\
  \hline \text { Best-case time } & O(m n) & O\left(m^{2}\right) \\
  \hline
  \end{array}
\end{equation}

\section*{Practical performance enhancements}
中・大規模の問題を解くことを目的としたシンプレックス法の実用的な実装には、
線形代数からの多くの考え方が取り入れられているため、簡単に紹介する。

最初の考え方は、再変換に関するものである。
修正シンプレクス法の各反復において、逆基底行列$\bm{B}^{-l}$はある規則に従って更新される。
このような反復は丸め誤差や切り捨て誤差を生じさせ、
それが累積して最終的に非常に不正確な結果をもたらす可能性がある。
このような理由から、何回かに一度、$\bm{B}^{-l}$を一から計算し直すことが一般的である。
このような再計算の効率は、適切なデータ構造と
線形代数のある種のテクニックを用いることで大きく向上させることができる。

もう一つの考え方は、逆基底行列$\bar{\bm{B}}^{-l}$の表現方法に関するものである。
再変換が行われたばかりで、$\bm{B}^{-l}$が利用可能であるとする。
修正シンプレックス法の現在の反復の後に、新しい逆基底行列$\bar{\bm{B}}^{-l}$を
明示的に生成して保存するオプションがある。$\bm{Q}\bm{B}^{-1}$となるような
行列$\bm{Q}$を格納することもできる。
これは完全な行列ではなく、$m$個の係数で完全に指定することができます。

ここで、$\bm{u}$について、$\bar{\bm{B}}\bm{u} = \bm{A}_j$
のシステムを解きたいとする。$\bm{A}_j$は、修正シンプレックス法で要求されるように、
入力列である。$\bm{u}=\bar{\bm{B}}^{-1}\bm{A}_j=\bm{Q}\bm{B}^{-1}\bm{A}_j$となり、
これは、まず$\bm{B}^{-1}\bm{A}_j$を計算し、次に$\bm{Q}$で左乗算
（等価に、一連のelelementary row operationを適用）して
$\bm{u}$を生成できることを示しています。
同じ考えで、数回のシンプレックス反復後の逆基底行列を、
最初の逆基底行列と$\bm{Q}$のようないくつかの疎行列の積として表すことも可能です。

最後に述べるのは、次のようなアイデアである。
通常$\bm{B}^{-1}$を明示的に計算するのではなく、
$\bm{B}^{-1}$を特殊な構造を持つ疎な三角行列の項で表現する。
本節で述べる方法は、数値安定性の向上（丸め誤差の影響の最小化）と、
問題データのスパース性を利用して実行時間と必要メモリを改善する、
という2つの目的を達成するために設計されたものである。
これらの方法は、実際には決定的な効果をもたらす。
数値的に信頼に足る結果を得る可能性が高いだけでなく、
シンプレックス法の実行時間を大幅に短縮することができる。
これらの手法は、最適化ではなく線形代数のテーマに近いものであるため、
これ以上深く説明しない。




\end{document}
